<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Canvas Circle Drawing</title>
        <style>
            canvas {
                border: 1px solid black;
                display: block;
                margin: 0 auto;
            }
            #container {
                position: relative;
            }
            
            #bordered-div {
                border: 2px solid black; /* border for the div */
                width: 80%;
                margin: 20px auto;
                padding: 10px;
                text-align: center;
            }
            #myButton {
                padding: 10px 20px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }
        </style>
    </head>

    <body>
        <div id="container">
            <canvas id="myCanvas" width="500" height="500"></canvas>
            <div id="ss">
                <div id = "bordered-div">
                    asdfgsdfgsgdf
                </div>
              <button id="myButton" onclick="buttonPress()">Click me</button>
            </div>
          </div>
    </body>

    <script>//down
        //function exportJSON() {
        //    
        //    var json = JSON.stringify(convertLinear(nodes, lines), null, 2); //convert to JSON
        //    downloadJSON(json, "downloadeddata.json");
        //    
        //}
        //
        //function downloadJSON(json, fileName){ //saves the json to users computer
        //    var a = document.createElement('a');
        //    a.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(json);
        //    a.download = fileName;
        //    a.click();
        //}

        randomBase()

        function loadJSON(file) { //loads a json from file by its path and return the parsed json
                return fetch(file)
                    .then(response => response.json())
                    .then(data => {
                        currentlyLoadedPzn = data;
                        setupPzn()
                        loadCustomEditor(0)
                    }).catch(error => {
                        console.error('Error:', error);
                    });
            }

        function buttonPress(){
            alert(compareLinearObjects(convertLinear(nodes, lines), loadJSON(document.getElementById("bordered-div").innerHTML+".json").data)?"correct!":"incorrect!")
            randomBase()
        }

        function randomBase(){
            const bases = ["adenine","guanine","cytosine","thymine"]
            document.getElementById("bordered-div").innerHTML = bases[Math.floor(Math.random()*4)];
        }


    </script>

    <script> //check and correct
        function getNodeLinearObject(node, connections){
            return {
                type: node.type,
                connections: connections
            };
        }

        // Calculate the angle between two points
        function calculateAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        function getConnectedNodes(node, lines, nodes) {
            // Initialize an array to store connected nodes with their angles
            var connectedNodesWithAngles = [];

            // Get the coordinates of the reference node
            const refX = node.x;
            const refY = node.y;

            

            // Calculate angles for each connected node
            lines.forEach(line => {
                if (line.startNodeId === node.id) {
                    // Find the connected node
                    const connectedNode = nodes.find(element => element.id === line.endNodeId);
                    // Calculate angle between reference node and connected node
                    const angle = calculateAngle(refX, refY, connectedNode.x, connectedNode.y);


                    // Push connected node and its angle to the array
                    connectedNodesWithAngles.push({ node: {node: connectedNode, count: line.count}, angle });
                }
                if (line.endNodeId === node.id) {
                    // Find the connected node
                    const connectedNode = nodes.find(element => element.id === line.startNodeId);
                    // Calculate angle between reference node and connected node
                    const angle = calculateAngle(refX, refY, connectedNode.x, connectedNode.y);
                    // Push connected node and its angle to the array
                    connectedNodesWithAngles.push({ node: {node: connectedNode, count: line.count}, angle });
                }
            });

            // Sort connected nodes based on angles
            connectedNodesWithAngles.sort((a, b) => a.angle - b.angle);

            // Extract nodes in sorted order
            const connectedNodes = connectedNodesWithAngles.map(item => item.node);

            return connectedNodes;
        }

        //convert a graph into simplified form
        function convertLinear(nodes, lines) {
            var linearData = [];
            nodes.forEach(node => {
                linearData.push(recurseNode(node, lines, nodes, 2));
            });
            return linearData;

        }


        function recurseNode(node, lines, nodes, depth) {
            if (depth < 1) {
                return getNodeLinearObject(node, []);
            }

            var connectedNodes = [];
            getConnectedNodes(node, lines, nodes).forEach(connectedNode => {
                let nodeObject = recurseNode(connectedNode.node, lines, nodes, depth-1);
                connectedNodes.push({count:connectedNode.count, node: nodeObject})
            });
            return getNodeLinearObject(node, connectedNodes);
        }

        function areListsSameCircular(list1, list2) {
            // Find the index of the smallest element in list1
            if(list1.length == 1) return (list1[0].count == list2[0].count && areTheSameNode(list1[0].node,list2[0].node))
            let shiftedArray = list2;
            for (let index = 0; index < list1.length; index++) {
                shiftedArray = [...shiftedArray.slice(1), shiftedArray[0]];
                var foundInconsistency = false;
                for (let j = 0; j < list1.length; j++) {
                    if(list1[j].count != shiftedArray[j].count || !areTheSameNode(list1[j].node,shiftedArray[j].node)){
                        foundInconsistency = true;
                        break;
                    }
                    
                }
                if (!foundInconsistency){
                    return true;
                }
                
            }
            return false;
        }
        function areListsSame(list1, list2) {
            


            // Create a copy of array2 to keep track of matched objects
            const copyArray2 = [...list2];

            // Iterate through array1
            for (let obj1 of list1) {
                // Flag to check if obj1 is found in array2
                
                let found = false;

                // Iterate through copyArray2
                for (let i = 0; i < copyArray2.length; i++) {
                    // Check if obj1 is the same as any object in copyArray2
                    if (areTheSameNode(obj1.node, copyArray2[i].node)) {
                        // If found, remove the object from copyArray2
                        copyArray2.splice(i, 1);
                        found = true;
                        break; // Exit the loop
                    }
                }

                // If obj1 is not found in array2, arrays don't contain the same objects
                if (!found) {
                    return false;
                }
            }

            // If all objects in array1 are found in array2, and vice versa, return true
            return true;
        }

        function areTheSameNode(node1, node2) {
            if(node1.type != node2.type) return false;
            if(node1.connections.length != node2.connections.length) return false;
            if(node1.connections.length == 0) return true;
            if(node1.connections.some(obj => obj.count > 1)){
                return areListsSameCircular(node1.connections, node2.connections);
            }else{
                return areListsSame(node1.connections, node2.connections);
            }

        }

        function compareLinearObjects(object1, object2) {
            if (object1.length !== object2.length) {
                return false; // If the arrays have different lengths, they can't contain the same objects
            }

            // Create a copy of array2 to keep track of matched objects
            const copyArray2 = [...object2];

            // Iterate through array1
            for (let obj1 of object1) {
                // Flag to check if obj1 is found in array2
                
                let found = false;

                // Iterate through copyArray2
                for (let i = 0; i < copyArray2.length; i++) {
                    // Check if obj1 is the same as any object in copyArray2
                    if (areTheSameNode(obj1, copyArray2[i])) {
                        // If found, remove the object from copyArray2
                        copyArray2.splice(i, 1);
                        found = true;
                        break; // Exit the loop
                    }
                }

                // If obj1 is not found in array2, arrays don't contain the same objects
                if (!found) {
                    return false;
                }
            }

            // If all objects in array1 are found in array2, and vice versa, return true
            return true;
        }

    </script>

    <script>//rendering

        var sizeMultiplier = 0.8;

        let nodes = [];
        let lines = [];
        var canvas    = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");

        const offscreenCanvas = document.createElement("canvas"); // Create offscreen canvas
        offscreenCanvas.width = 500;
        offscreenCanvas.height = 500;
        const offscreenCtx = offscreenCanvas.getContext("2d");

        var highlightedNodeId = null;

        // Function to draw a node
        function drawNode(node, context, isSelected) {

            let text = node.type;

            let isNodeConnected = getAnyLineOfANode(node.id) != null;

            if(node.id != selectedNodeId && text.length == 0){
                removeNodeAndConnections(node.id); 
                return;
            }

            if(node.type == "C" && isNodeConnected && node.id != selectedNodeId && node.id != highlightedNodeId){return;}


            context.beginPath();
            context.arc(node.x , node.y, node.radius, 0, 2 * Math.PI);
            if (node.id === selectedNodeId) {
                context.strokeStyle = "black"; // Outline color
                context.lineWidth = 2; // Outline width
                context.stroke();
            }
            else if (node.id === highlightedNodeId) {
                context.strokeStyle = "red"; // Outline color
                context.lineWidth = 2; // Outline width
                context.stroke();
            }
            
            context.fillStyle = "white"; // Fill color
            context.fill();

            context.textAlign = "left";
            context.textBaseline = "middle";
            context.fillStyle = "black";
            // Start with a large font size
            var fontSize = 40;

            do {
                // Set font properties
                context.font = fontSize + "px Arial";
                
                // Measure text width
                var textWidth = ctx.measureText(text.charAt(0)).width;
                
                // Decrease font size if text width is greater than circle diameter
                if (textWidth > node.radius * 2) {
                    node.radius--;
                }
            } while (textWidth > node.radius * 2 - 5*sizeMultiplier && fontSize > 0);

            



            context.font = fontSize*sizeMultiplier+"px Arial"

            context.fillText(node.type, node.x- ctx.measureText(text.charAt(0)).width*1.6, node.y);

            

            //const img = new Image();
            //img.src = getNodeSpriteUrl(node.type);
            //img.onload = function() {
            //    context.drawImage(img, node.x - node.radius, node.y - node.radius, node.radius * 2, node.radius * 2);
            //    if (node.id === selectedNodeId) {
            //        // Draw border or change color to indicate selection
            //        context.strokeStyle = "blue"; // Change to desired color
            //        context.lineWidth = 2; // Change to desired border width
            //        context.strokeRect(node.x - node.radius - 1, node.y - node.radius - 1, node.radius * 2 + 2, node.radius * 2 + 2);
            //    }
            //};
        }

        const connectionWidth = 2;

        // Function to draw a line
        function drawLine(line, context, count, isBlack) {
            const startNode = nodes.find(element => element.id === line.startNodeId);
            const endNode = nodes.find(element => element.id === line.endNodeId);
            context.strokeStyle = isBlack ? "white":"black"; // Change to desired color
            context.beginPath();
            context.moveTo(startNode.x, startNode.y);
            context.lineTo(endNode.x, endNode.y);
            context.lineWidth = connectionWidth * count;
            context.stroke();
            if(count > 1) drawLine(line, context, count-2, !isBlack);
        }

        function drawLineToMouse(startNodeId, mousePosX, mousePosY, context) {
            const startNode = nodes.find(element => element.id === startNodeId);
            context.strokeStyle = "black"; // Change to desired color
            context.beginPath();
            context.moveTo(startNode.x, startNode.y);
            context.lineTo(mousePosX, mousePosY);
            context.lineWidth = connectionWidth * 1;

            context.stroke();
        }

        // Function to get node sprite URL based on type
        function getNodeSpriteUrl(type) {
            return type + ".png";
        }


        function redrawCanvas() {
            // Clear offscreen canvas
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

            lines.forEach(element => {drawLine(element, offscreenCtx, (element.count * 2 - 1), !element.count%2);});

            if(clickedNode != null && currentMouseX != null && isMouseDown){
                drawLineToMouse(clickedNode.id, currentMouseX, currentMouseY, offscreenCtx);
            }

            // Draw elements on offscreen canvas
            nodes.forEach(element => {drawNode(element, offscreenCtx);});

            
            //if(mouseDown){
            //    const startNode = clickedNode;
            //    offscreenCtx.strokeStyle = "black"; // Change to desired color
            //    offscreenCtx.beginPath();
            //    offscreenCtx.moveTo(startNode.x, startNode.y);
            //    offscreenCtx.lineTo(currentMousePos.x, currentMousePos.y);
            //    offscreenCtx.lineWidth = connectionWidth * 1;
            //    offscreenCtx.stroke();
            //}
            
                

            // Copy offscreen canvas to the visible canvas
            setTimeout(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.drawImage(offscreenCanvas, 0, 0);
                
            }, 10);
        }

        var currentID = 0;

        function newId(){
            currentID++;
            return currentID;
        }

    </script>

    <script>

        function distanceSquared(x1, y1, x2, y2) {
            return (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function getNodeAtPos(x,y){

            var clickedNode = null;
            nodes.forEach(node => {
                    let dist = distanceSquared(node.x, node.y, x, y)
                    if(dist < node.radius**2){

                        clickedNode = node;
                    }
            });
            return clickedNode;
        }

        function connectNodes(id1, id2){
            lines.push({
                id: newId(),
                shape: "line",
                startNodeId: id1,
                endNodeId: id2,
                count: 1
            });
        }


        function newNode(x,y,connectTo) {

            let newNodeId = newId();

            nodes.push({
                id: newNodeId,
                shape: "node",
                type: "C", // Set the type of node as needed
                radius: 20 * sizeMultiplier, // Set the radius as needed
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                mass: 1
            })
            
            if(connectTo){
                connectNodes(connectTo, newNodeId);
            }
            
            selectedNodeEdited = false;

            return newNodeId;

        }

        function connectionExists(startNodeId, endNodeId) {
            return lines.find(line => {
                return (line.startNodeId === startNodeId && line.endNodeId === endNodeId) || (line.startNodeId === endNodeId && line.endNodeId === startNodeId);
            });
        }

        function getAnyLineOfANode(nodeId) {
            return lines.find(line => {
                return line.startNodeId == nodeId || line.endNodeId === nodeId;
            });
        }

        function getNodeById(nodeId) {
            return nodes.find(node => node.id === nodeId);
        }

        function removeNodeAndConnections(nodeId){
        

            nodes = nodes.filter(node=>{
                return node.id !== nodeId;
            })

            lines = lines.filter(line=>{
                return line.startNodeId !== nodeId && line.endNodeId !== nodeId;
            })
        }

        function removeConnection(connectionId){
            lines = lines.filter(line=>{
                return line.id != connectionId;
            })
        }

        const subscriptMap = {
            '0': '₀',
            '1': '₁',
            '2': '₂',
            '3': '₃',
            '4': '₄',
            '5': '₅',
            '6': '₆',
            '7': '₇',
            '8': '₈',
            '9': '₉'
        };

        var selectedNodeEdited = false;

        var selectedNodeId = null; // Store the ID of the last added node

        document.addEventListener("keydown", function(event) {
            const key = event.key;

            let selectedNode = getNodeById(selectedNodeId);
            // Check if specific keys are pressed

            if(!selectedNodeEdited){
                selectedNode.type = "";
                selectedNodeEdited = true;
            }


            if(key == "Delete") {
                removeNodeAndConnections(selectedNode.id);
                return;
            }
            
            if(key.length == 1 && /[a-zA-Z]/.test(key)) selectedNode.type = selectedNode.type + key.toUpperCase();

            if (/^\d$/.test(event.key)) selectedNode.type = selectedNode.type + subscriptMap[key];

            if(key == "Backspace") selectedNode.type = selectedNode.type.slice(0, -1);

            
        
        });

        function deselect(){
            selectedNodeId = null; //deselect
            selectedNodeEdited = false;
        }

        function select(node){
            selectedNodeId = node.id;
            selectedNodeEdited = false;
        }
        var mouseTimer = 0;

        setInterval(() => {
            mouseTimer += 0.1;
            
        }, 100);

        var currentMouseX = null;
        var currentMouseY = null;
        var clickedNode = null;
        var isMouseDown = false;


        document.addEventListener("DOMContentLoaded", function() {
            
            canvas.addEventListener("contextmenu", function(event) {
                event.preventDefault(); // Prevent default context menu
            });
            
            //canvas.addEventListener("contextmenu", function(event) {
            //    event.preventDefault(); // Prevent default context menu
            //});
            // Function to handle click event

            
            

            var clickedPos = null;



            

            canvas.addEventListener("mousemove", function(event){
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                var overNode = getNodeAtPos(x,y);

                if(overNode != null) {
                    highlightedNodeId = overNode.id
                }
                else{
                    highlightedNodeId = null;
                }



                currentMouseX = x;
                currentMouseY = y;
            })

            

            canvas.addEventListener("mouseup", function(event) {
                isMouseDown = false;

                let button = event.button;


                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                var releasedNode = getNodeAtPos(x,y);

                if(button == 2) {

                    deselect();

                    event.preventDefault();

                }

                if(button == 1) {

                    if(releasedNode){
                        removeNodeAndConnections(releasedNode.id);
                        deselect();
                    }

                    event.preventDefault();

                }


                if(button == 0) {

                    const tapped = mouseTimer < 0.2;


                    if(tapped && releasedNode == null){  //tapped in air
                        if(selectedNodeId != null){
                            deselect()

                        }else{
                            selectedNodeId = newNode(x,y,null);
                        }
                    }

                    if(tapped && releasedNode != null){ //tapped on a node
                        select(releasedNode);
                    }

                    if(!tapped && releasedNode == null){ //dragged into air
                        if(clickedNode != null) {
                            selectedNodeId = newNode(x,y,clickedNode.id); //make a new node connected to the selected
                        }else{
                            return;
                            //let initialNodeId = newNode(clickedPos.x,clickedPos.y,null); //make a new node 
                            //let secondNodeId = newNode(x,y,null);
                            //selectedNodeId = secondNodeId; //make a new node 
                            //connectNodes(initialNodeId,secondNodeId);
                        }
                    }

                    if(!tapped && releasedNode != null){ //dragged onto a node
                        if(clickedNode.id == releasedNode.id) return;
                        let connection = connectionExists(clickedNode.id, releasedNode.id);
                        if(connection != null){
                            if (connection.count === 3) {
                                removeConnection(connection.id); 
                            } else {
                                connection.count++;
                            }
                        }else{ //connection does not exist
                            connectNodes(clickedNode.id, releasedNode.id);
                            select(releasedNode);
                        }
                    }

                    

                    
                }

                clickedPos = null;

            })

            

            canvas.addEventListener("mousedown", function(event) {

                isMouseDown = true;
                mouseTimer = 0;




                let button = event.button;


                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                clickedPos = (x,y);

                let connected = false;

                clickedNode = getNodeAtPos(x,y);


                

                

                redrawCanvas();
                
            });
        });



    </script>

    <script>//sim
    
            // Constants
        const springConstant = 0.1;
        const dampingFactor = 0.05;
        const repulsionConstant = 100;

        // Initialize nodes and lines (assuming you have them stored in 'nodes' and 'lines' arrays)

        // Example arrays
        

        

        

        // Function to calculate distance between two points
        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        // Function to calculate spring force between two nodes
        function springForce(node1, node2) {
            const distanceBetweenNodes = distance(node1.x, node1.y, node2.x, node2.y);
            const displacement = distanceBetweenNodes - 100*sizeMultiplier; // You need to define this value
            const forceMagnitude = springConstant * displacement;
            const dx = (node2.x - node1.x) / distanceBetweenNodes;
            const dy = (node2.y - node1.y) / distanceBetweenNodes;
            return { fx: forceMagnitude * dx, fy: forceMagnitude * dy };
        }

        //
        function repulsionForce(node, otherNode) {
            const dx = otherNode.x - node.x;
            const dy = otherNode.y - node.y;
            const distanceSquared = dx * dx + dy * dy;
            const distance = Math.sqrt(distanceSquared);

            // Calculate force magnitude (inverse relationship with distance)
            const forceMagnitude = (-1 / distanceSquared) * repulsionConstant;

            // Calculate force components
            const fx = forceMagnitude * (dx / distance);
            const fy = forceMagnitude * (dy / distance);

            return { fx, fy };
        }

       

        // Function to update positions and velocities of nodes
        function updateNodes() {

            if (nodes.length == 0) return;

            let sumx = 0;
            let sumy = 0;
            nodes.forEach(node => {
                sumx += node.x - 250;
                sumy += node.y - 250;
            })

            sumx = (sumx / nodes.length) * -0.01;
            sumy = (sumy / nodes.length) * -0.01;

            nodes.forEach(node => {
                let totalForceX = 0;
                let totalForceY = 0;
                
                // Calculate spring forces from connected nodes
                lines.forEach(line => {
                    if (line.startNodeId === node.id) {
                        const connectedNode = nodes.find(n => n.id === line.endNodeId);
                        const { fx, fy } = springForce(node, connectedNode);
                        totalForceX += fx;
                        totalForceY += fy;
                    } else if (line.endNodeId === node.id) {
                        const connectedNode = nodes.find(n => n.id === line.startNodeId);
                        const { fx, fy } = springForce(node, connectedNode);
                        totalForceX += fx;
                        totalForceY += fy;
                    }
                });
                
                // Calculate repulsion forces between all nodes
                nodes.forEach(otherNode => {
                    if (node.id !== otherNode.id) {
                        const { fx, fy } = repulsionForce(node, otherNode);
                        totalForceX += fx;
                        totalForceY += fy;
                    }
                });

                // Apply damping
                totalForceX -= dampingFactor * node.vx;
                totalForceY -= dampingFactor * node.vy;


                node.vx = 0;
                node.vy = 0;

                // Update velocity
                node.vx += totalForceX + sumx;
                node.vy += totalForceY + sumy;

                // Update position
                node.x += node.vx;
                node.y += node.vy;

            });
        }

        setInterval(() => {
             // Update positions of nodes
             updateNodes();

            // Render nodes and lines (not implemented here)
            redrawCanvas();

            

        }, 100);

        

    </script>
</html>
